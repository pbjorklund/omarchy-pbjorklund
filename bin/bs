#!/usr/bin/env python3

import argparse
import json
import os
import re
import subprocess
import sys
import tempfile
import time
from pathlib import Path

def setup_venv_path():
    script_dir = Path(__file__).parent.parent if Path(__file__).parent.name == 'bin' else Path(__file__).parent
    possible_venvs = [
        script_dir / 'venv',
        Path.home() / 'omarchy-pbjorklund' / 'venv',
        Path('/usr/local/share/omarchy-pbjorklund/venv'),
    ]
    
    for venv_path in possible_venvs:
        site_packages = venv_path / 'lib'
        if site_packages.exists():
            for python_dir in site_packages.iterdir():
                if python_dir.name.startswith('python3.'):
                    pkg_path = python_dir / 'site-packages'
                    if pkg_path.exists():
                        sys.path.insert(0, str(pkg_path))
                        return True
    return False

setup_venv_path()

try:
    from atproto import Client, models
    from atproto.exceptions import AtProtocolError
except ImportError as e:
    print(f"Error: Required Python libraries not found: {e}")
    print("Please run: install-scripts/install-bs-dependencies.sh")
    sys.exit(1)


class BlueskyPoster:
    BSKY_LIMIT = 290
    MASTODON_LIMIT = 500

    def __init__(self):
        self.config_path = Path.home() / '.config' / 'bsky' / 'config.json'
        self.client = None

    def load_bsky_credentials(self):
        if not self.config_path.exists():
            return None, None
        
        try:
            with open(self.config_path, 'r') as f:
                config = json.load(f)
            return config.get('handle'), config.get('password')
        except (json.JSONDecodeError, KeyError, FileNotFoundError):
            return None, None

    def get_bsky_client(self):
        if self.client is not None:
            return self.client
        
        handle, password = self.load_bsky_credentials()
        if not handle or not password:
            print("Bluesky config not found or incomplete at ~/.config/bsky/config.json")
            return None
        
        try:
            self.client = Client()
            self.client.login(handle, password)
            return self.client
        except AtProtocolError as e:
            print(f"Failed to authenticate with Bluesky: {e}")
            return None

    # Removed liking functionality to keep tool focused on posting

    def split_text_for_bluesky(self, text):
        if not text or len(text) <= self.BSKY_LIMIT:
            return [text] if text else [""]
        
        parts = []
        lines = text.split('\n')
        current_chunk = ""
        
        for line in lines:
            potential_chunk = line if not current_chunk else f"{current_chunk}\n{line}"
            
            if len(potential_chunk) <= self.BSKY_LIMIT:
                current_chunk = potential_chunk
            else:
                if current_chunk:
                    parts.append(current_chunk)
                    current_chunk = line
                else:
                    remaining = line
                    while remaining:
                        if len(remaining) <= self.BSKY_LIMIT:
                            current_chunk = remaining
                            break
                        
                        # Find word boundary to break at
                        break_pos = self.BSKY_LIMIT
                        for i in range(self.BSKY_LIMIT, max(0, self.BSKY_LIMIT - 50), -1):
                            if i < len(remaining) and remaining[i] == ' ':
                                break_pos = i
                                break
                        
                        parts.append(remaining[:break_pos])
                        remaining = remaining[break_pos:].lstrip()
        
        if current_chunk:
            parts.append(current_chunk)
        
        return parts

    def post_to_bluesky(self, message):
        client = self.get_bsky_client()
        if not client:
            return False
        
        print("Posting to Bluesky...")
        parts = self.split_text_for_bluesky(message)
        
        try:
            if len(parts) == 1:
                post = client.send_post(parts[0])
                print(f"✓ Bluesky: {post.uri}")
                return True
            
            print(f"Creating thread with {len(parts)} parts...")
            root_post = parent_post = None
            
            for i, part in enumerate(parts):
                if parent_post is None:
                    post = client.send_post(part)
                    root_post = parent_post = post
                    print(f"✓ Bluesky thread part {i+1}/{len(parts)}: {post.uri}")
                else:
                    parent_ref = models.ComAtprotoRepoStrongRef.Main(
                        cid=parent_post.cid,
                        uri=parent_post.uri
                    )
                    root_ref = models.ComAtprotoRepoStrongRef.Main(
                        cid=root_post.cid,
                        uri=root_post.uri
                    )
                    reply_ref = models.AppBskyFeedPost.ReplyRef(
                        parent=parent_ref,
                        root=root_ref
                    )
                    reply = client.send_post(part, reply_to=reply_ref)
                    parent_post = reply
                    print(f"✓ Bluesky thread part {i+1}/{len(parts)}: {reply.uri}")
                
                time.sleep(0.5)
            
            return True
        except AtProtocolError as e:
            print(f"Bluesky failed: {e}")
            return False

    def post_to_mastodon(self, message):
        if not self.command_exists('toot'):
            print("toot command not found - install with: yay -S toot")
            return False
        
        print("Posting to Mastodon...")
        
        try:
            result = subprocess.run(
                ['toot', 'post', message],
                capture_output=True, text=True, check=True
            )
            print("✓ Mastodon: Posted successfully")
            return True
        except subprocess.CalledProcessError as e:
            print(f"Mastodon error: {e.stderr}")
            return False

    def post_to_services(self, message):
        bsky_success = self.post_to_bluesky(message)
        toot_success = self.post_to_mastodon(message)
        
        if bsky_success and toot_success:
            self.notify("Social Media", "Posted to both Bluesky and Mastodon!")
            return True
        elif bsky_success:
            self.notify("Social Media", "Posted to Bluesky only")
            return True
        elif toot_success:
            self.notify("Social Media", "Posted to Mastodon only") 
            return True
        else:
            self.notify("Social Media Error", "Failed to post to both platforms")
            return False

    def get_message_from_editor(self):
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as temp_file:
            temp_path = temp_file.name
        
        try:
            subprocess.run(['nvim', temp_path], check=True)
            
            with open(temp_path, 'r') as f:
                content = f.read().strip()
            
            if not content:
                print("No content to post (file empty or :q without saving)")
                return None
            
            return content
            
        except subprocess.CalledProcessError:
            print("Editor cancelled")
            return None
        finally:
            if os.path.exists(temp_path):
                os.unlink(temp_path)

    def command_exists(self, command):
        return subprocess.run(['which', command], 
                            capture_output=True).returncode == 0

    def notify(self, title, message):
        if self.command_exists('notify-send'):
            subprocess.run(['notify-send', title, message], 
                         capture_output=True)

    def main(self):
        parser = argparse.ArgumentParser(
            description='Post to Bluesky and Mastodon'
        )
        parser.add_argument('message', nargs='*', 
                          help='Message to post (if omitted, reads stdin or opens editor)')
        
        args = parser.parse_args()
        
        if args.message:
            message = ' '.join(args.message)
        elif not sys.stdin.isatty():
            message = sys.stdin.read().strip()
            if not message:
                print("No content to post")
                return 1
        else:
            message = self.get_message_from_editor()
            if message is None:
                return 1
        
        success = self.post_to_services(message)
        return 0 if success else 1


if __name__ == '__main__':
    poster = BlueskyPoster()
    sys.exit(poster.main())